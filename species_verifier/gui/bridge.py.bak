"""
브릿지 모듈 - 종 검증 애플리케이션

이 모듈은 GUI와 검증 로직 사이의 브릿지 역할을 합니다.
파일 처리, 검증 로직 등 공통 기능을 제공합니다.
취소 기능이 모든 검증 시스템에서 일관되게 작동하도록 개선되었습니다.
"""
import sys
import traceback
import types  
import pandas as pd
from typing import List, Dict, Any, Union, Tuple, Optional, Callable
import sys  # 추가
import os   # 추가
import pandas as pd # 추가 (process_file 내부 import 제거 가능)
from pathlib import Path # 추가
import asyncio

# 기존 main_gui.py의 함수를 직접 임포트하기 위한 try-except
try:
    from species_verifier.gui.main_gui_backup import (
        _perform_verification as original_perform_verification,
        _perform_microbe_verification as original_perform_microbe_verification,
        _process_file as original_process_file,
        _process_microbe_file as original_process_microbe_file,
        _get_wiki_summary as original_get_wiki_summary,
        # KOREAN_NAME_MAPPINGS # 기존 JSON 매핑 임포트 제거
    )
    
    # 임포트 성공 로그
    print("[Info] Successfully imported original functions from main_gui.py")
    
except ImportError as e:
    print(f"[Error] Failed to import original functions from main_gui.py: {e}")
    # 더미 함수 정의
    def original_perform_verification(verification_list_input, update_progress=None, update_status=None, result_callback=None, check_cancelled=None):
        print(f"[Warning] Using original_perform_verification function with {len(verification_list_input)} items")
        
        # 결과 저장 리스트
        results = []
        
        # 진행 상태 업데이트 함수가 제공된 경우 사용
        if update_status:
            update_status(f"해양생물 검증 시작 (총 {len(verification_list_input)}개)")
        
        # 각 항목에 대해 처리 - 연결된 취소 확인 기능 수정
        for idx, item in enumerate(verification_list_input):
            # 항목 처리 전마다 취소 여부 확인
            cancelled = False
            
            # 디버그 로그 추가 - 취소 확인 함수 호출 과정 추적
            if check_cancelled:
                print(f"[Debug Cancel] 아이템 {idx+1}/{len(verification_list_input)} 처리 전 취소 확인 시도")
                
                # 예외 처리를 통해 안정적인 취소 확인
                try:
                    if isinstance(check_cancelled, types.FunctionType) or callable(check_cancelled):
                        # 인자 없이 호출 시도
                        cancelled = check_cancelled()
                        print(f"[Debug Cancel] 취소 확인 결과(0 인자): {cancelled}")
                    else:
                        print(f"[Debug Cancel] 취소 함수가 호출 가능하지 않음: {type(check_cancelled)}")
                except TypeError:
                    # 호출 에러가 발생하면 인자를 전달해 보자
                    try:
                        cancelled = check_cancelled(idx)
                        print(f"[Debug Cancel] 취소 확인 결과(1 인자): {cancelled}")
                    except Exception as e2:
                        print(f"[Error Cancel] 인자를 전달한 취소 확인 중 오류: {e2}")
                except Exception as e:
                    print(f"[Error Cancel] 취소 확인 중 예상치 못한 오류: {e}")
            
            if cancelled:
                print(f"[Info Bridge] 취소 요청 받음 - 아이템 {idx+1}/{len(verification_list_input)} 처리 후 반복 중단")
                break
                
            # 진행률 업데이트
            if update_progress:
                progress = (idx + 1) / len(verification_list_input)
                print(f"[Debug Original] 해양생물 진행률 계산: {progress:.2f}, 현재 항목: {idx+1}, 전체 항목 수: {len(verification_list_input)}")
                # 현재 항목과 전체 항목 수도 함께 전달
                update_progress(progress, idx+1, len(verification_list_input))
            
            # 상태 메시지 업데이트
            item_name = item[0] if isinstance(item, tuple) else item
            if update_status:
                update_status(f"해양생물 검증 중: {item_name} ({idx+1}/{len(verification_list_input)}) - 전체 {len(verification_list_input)}개 중 {idx+1}번째")
            
            # 간단한 결과 생성 (실제 검증 없이)
            result = {
                "scientific_name": item_name,
                "status": "unknown",
                "matched_name": item_name,
                "authority": "",
                "rank": "Species",
                "source": "WoRMS",
                "wiki_summary": "",
                "confidence": 0.0
            }
            
            # 결과 리스트에 추가
            results.append(result)
            
            # 콜백 함수가 제공된 경우 호출
            if result_callback:
                result_callback(result, "marine")
        
        return results
    
    def original_perform_microbe_verification(microbe_names_list, update_progress=None, update_status=None, result_callback=None, context=None, check_cancelled=None):
        print(f"[Warning] Using original_perform_microbe_verification function with {len(microbe_names_list)} items")
        
        # 결과 저장 리스트
        results = []
        
        # 진행 상태 업데이트 함수가 제공된 경우 사용
        if update_status:
            update_status(f"미생물 검증 시작 (총 {len(microbe_names_list)}개)")
        
        # 각 항목에 대해 처리
        for idx, name in enumerate(microbe_names_list):
            # 취소 여부 확인
            if check_cancelled and check_cancelled():
                print("[Info Bridge] Original 함수에서 검증 취소 요청 받음 - 반복 중단")
                break
                
            # 진행률 업데이트
            if update_progress:
                progress = (idx + 1) / len(microbe_names_list)
                print(f"[Debug Original] 미생물 진행률 계산: {progress:.2f}, 현재 항목: {idx+1}, 전체 항목 수: {len(microbe_names_list)}")
                # 현재 항목과 전체 항목 수도 함께 전달
                update_progress(progress, idx+1, len(microbe_names_list))
            
            # 상태 메시지 업데이트
            if update_status:
                update_status(f"미생물 검증 중: {name} ({idx+1}/{len(microbe_names_list)}) - 전체 {len(microbe_names_list)}개 중 {idx+1}번째")
            
            # 간단한 결과 생성 (실제 검증 없이)
            result = {
                "scientific_name": name,
                "status": "unknown",
                "matched_name": name,
                "authority": "",
                "rank": "Species",
                "source": "LPSN",
                "wiki_summary": "",
                "confidence": 0.0
            }
            
            # 결과 리스트에 추가
            results.append(result)
            
            # 콜백 함수가 제공된 경우 호출
            if result_callback:
                result_callback(result, "microbe")
        
        return results
    
    def original_process_file(*args, **kwargs):
        print("[Warning] Using dummy process_file function")
        return []
    
    def original_process_microbe_file(*args, **kwargs):
        print("[Warning] Using dummy process_microbe_file function")
        return []
    
    def original_get_wiki_summary(*args, **kwargs):
        print("[Warning] Using dummy get_wiki_summary function")
        return "정보 없음 (더미 함수)"

# --- 국명-학명 매핑 로딩 로직 (Excel 파일 기반) ---

def get_base_path():
    """ 실행 파일의 기본 경로를 반환합니다 (개발 환경과 .exe 환경 모두 지원). """
    if getattr(sys, 'frozen', False):
        # .exe로 실행될 때
        return Path(sys.executable).parent
    else:
        # 스크립트로 실행될 때 (.py)
        # bridge.py는 gui 폴더 안에 있으므로, 프로젝트 루트는 두 단계 위입니다.
        return Path(__file__).resolve().parent.parent.parent

def load_korean_mappings_from_excel() -> Dict[str, str]:
    """ 실행 파일 옆의 data 폴더에 있는 Excel 파일에서 매핑을 로드합니다. """
    base_path = get_base_path()
    # 'data' 하위 폴더에 있다고 가정
    excel_path = base_path / "data" / "korean_mappings.xlsx"
    print(f"[Info Bridge] Attempting to load Korean mappings from: {excel_path}")

    mappings = {}
    if excel_path.exists():
        try:
            df = pd.read_excel(excel_path, header=0) # 첫 번째 행을 헤더로 사용
            # '국명', '학명' 컬럼이 있는지 확인 (대소문자, 공백 무시)
            df.columns = [str(col).strip().lower() for col in df.columns] # 컬럼명을 문자열로 변환 후 처리
            required_cols = ['국명', '학명']
            if all(col in df.columns for col in required_cols):
                # NaN 값 제거 후 딕셔너리 생성 (국명과 학명 모두 문자열로 변환)
                df_cleaned = df[required_cols].dropna()
                df_cleaned['국명'] = df_cleaned['국명'].astype(str)
                df_cleaned['학명'] = df_cleaned['학명'].astype(str)
                # 중복된 국명이 있을 경우 마지막 값 사용 (기본 동작)
                mappings = pd.Series(df_cleaned.학명.values, index=df_cleaned.국명).to_dict()
                print(f"[Info Bridge] Loaded {len(mappings)} Korean mappings from {excel_path}")
            else:
                print(f"[Error Bridge] Excel file {excel_path} missing required columns '국명' or '학명'. Found columns: {df.columns.tolist()}")

        except Exception as e:
            print(f"[Error Bridge] Failed to load or parse Excel mappings from {excel_path}: {e}")
            import traceback
            traceback.print_exc()
    else:
        print(f"[Warning Bridge] Mapping file not found at {excel_path}. Korean name lookup will not work.")
    return mappings

# KOREAN_NAME_MAPPINGS 딕셔너리를 Excel 로딩 함수 호출 결과로 초기화
KOREAN_NAME_MAPPINGS: Dict[str, str] = load_korean_mappings_from_excel()

# 코어 모듈 임포트 시도 (수정: 클래스 임포트 복원)
try:
    from species_verifier.core.marine_verifier import MarineSpeciesVerifier
    from species_verifier.core.wiki import get_wiki_summary
    from species_verifier.core.microbe_verifier import MicrobeVerifier
    # 함수 직접 임포트 제거
    # from species_verifier.core.verifier import verify_marine_species, verify_microbe_species
    
    HAS_CORE_MODULES = True
    print("[Info] Successfully imported core Verifier classes") # 로그 메시지 변경
    
except ImportError as e:
    print(f"[Error] Failed to import core modules: {e}")
    HAS_CORE_MODULES = False
    # 클래스 임포트 실패 시 None 할당
    MarineSpeciesVerifier = None
    MicrobeVerifier = None

def perform_verification(verification_list_input, update_progress=None, update_status=None, result_callback=None, check_cancelled=None):
    """
    해양생물 검증 함수 - 공통 검증 루프 사용
    
    Args:
        verification_list_input: 검증할 목록
        update_progress: 진행률 업데이트 콜백
        update_status: 상태 업데이트 콜백
        result_callback: 개별 결과 업데이트 콜백
        check_cancelled: 취소 여부 확인 함수
        
    Returns:
        검증 결과 목록
    """
    # 공통 검증 모듈 사용
    from species_verifier.gui.common_verifier import perform_common_verification
    from species_verifier.core.verifier import verify_species
    
    # 개별 검증 함수 정의
    def verify_item(item):
        """개별 항목 검증 함수"""
        # 항목이 튜플/리스트인 경우 (한글명, 학명)
        if isinstance(item, (tuple, list)):
            scientific_name = item[1] if len(item) > 1 else item[0]  # 학명 쿼리
            input_name = item[0]  # 원본 입력 이름
            result = verify_species(scientific_name)
            result['input_name'] = input_name  # 원본 입력 이름 추가
        else:
            # 일반 학명 문자열인 경우
            result = verify_species(item)
            result['input_name'] = item  # 입력 이름 추가
        
        return result
    
    print(f"[Info Bridge] 해양생물 검증 시작 - 공통 검증 모듈 사용 (총 {len(verification_list_input)}개 항목)")
    
    # 공통 검증 루프 사용
    results = perform_common_verification(
        items_list=verification_list_input,
        verification_function=verify_item,
        update_progress=update_progress,
        update_status=update_status,
        result_callback=lambda result, verification_type='marine': result_callback(result, verification_type) if result_callback else None,
        check_cancelled=check_cancelled,
        verification_type="marine"
    )
    
    return results
                if update_progress:
                    update_progress(1.0, len(verification_list_input), len(verification_list_input))
                
                # 상태 메시지 업데이트
                if update_status:
                    update_status(f"해양생물 검증 완료: 전체 {len(verification_list_input)}개 항목 처리됨")
                    
            except Exception as batch_e:
                print(f"[Error Bridge] 일괄 검증 중 오류 발생: {batch_e}")
                
                # 오류 발생 시 원래 방식(개별 처리)으로 폴백
                print("[Info Bridge] 개별 처리 방식으로 폴백합니다")
                results = []
                for i, item in enumerate(verification_list_input):
                    # 취소 여부 확인
                    if check_cancelled and check_cancelled():
                        print("[Info Bridge] 해양생물 검증 취소 요청 받음 - 반복 중단")
                        break
                    
                    # 진행률 업데이트
                    if update_progress:
                        progress = (i + 1) / len(verification_list_input)
                        print(f"[Debug Bridge Progress] 해양생물 진행률 계산: {progress:.2f}, 현재 항목: {i+1}, 전체 항목 수: {len(verification_list_input)}")
                        # 현재 항목과 전체 항목 수도 함께 전달
                        update_progress(progress, i+1, len(verification_list_input))
                    
                    # 상태 메시지 업데이트
                    if update_status:
                        item_name = item[0] if isinstance(item, tuple) else item
                        update_status(f"해양생물 검증 중: {item_name} ({i+1}/{len(verification_list_input)}) - 전체 {len(verification_list_input)}개 중 {i+1}번째")
                    
                    # 단일 항목 검증 실행
                    try:
                        # 하나의 항목만 전달하여 검증
                        single_item = [item]
                        single_result = verifier.perform_verification(single_item)
                        if single_result and len(single_result) > 0:
                            # 결과가 있는 경우 추가
                            results.extend(single_result)
                    except Exception as item_e:
                        print(f"[Error Bridge] 항목 '{item}' 검증 중 오류: {item_e}")
            
            # 결과 확인
            print(f"[Debug Bridge] 검증 결과 수: {len(results) if results else 0}")
            return results
        except Exception as e:
            print(f"[Error] Core module verification failed, falling back to original: {e}")
            
            # 원본 함수에 맞게 어댑터 함수 생성 - 더 강화된 버전
            def check_cancelled_adapter(*args):
                # 디버그 로그 추가 - 호출 시간 추적
                print(f"[Debug Cancel] try-except 내 check_cancelled_adapter 호출됨 (args: {args})")
                
                # 취소 함수가 존재하는지 확인
                if not check_cancelled:
                    print("[Debug Cancel] 취소 확인 함수가 None입니다")
                    return False
                
                # 취소 함수 호출 시도 (안정적 방식)
                try:
                    # 인자 없이 호출
                    result = check_cancelled()
                    print(f"[Debug Cancel] try-except 내 취소 확인 결과: {result}")
                    return result
                except TypeError:
                    # 인자가 있는 함수일 수 있으니 인자 전달 시도
                    try:
                        result = check_cancelled(0)  # 물리적 인덱스 전달
                        print(f"[Debug Cancel] 인자가 있는 취소 확인 결과: {result}")
                        return result
                    except Exception as inner_e:
                        print(f"[Error Cancel] 인자 전달 시도 중 오류: {inner_e}")
                        # 오류에도 불구하고 취소를 시도해보자
                        return True
                except Exception as e:
                    print(f"[Error Cancel] try-except 내 check_cancelled_adapter 에서 오류: {e}")
                    # 예외 발생 시 안전하게 취소를 반환
                    return True
                
            print("[Warning] Using original_perform_verification function with " + str(len(verification_list_input)) + " items")
            return original_perform_verification(verification_list_input, update_progress, update_status, result_callback, check_cancelled_adapter)
    else:
        print("[Bridge] Falling back to original_perform_verification")
        
        # 원본 함수에 맞게 어댑터 함수 생성 - 더 강화된 버전
        def check_cancelled_adapter(*args):
            # 디버그 로그 추가 - 호출 시간 추적
            print(f"[Debug Cancel] else 블록의 check_cancelled_adapter 호출됨 (args: {args})")
            
            # 취소 함수가 존재하는지 확인
            if not check_cancelled:
                print("[Debug Cancel] 취소 확인 함수가 None입니다")
                return False
            
            # 취소 함수 호출 시도 (안정적 방식)
            try:
                # 인자 없이 호출
                result = check_cancelled()
                print(f"[Debug Cancel] else 블록의 취소 확인 결과: {result}")
                return result
            except TypeError:
                # 인자가 있는 함수일 수 있으니 인자 전달 시도
                try:
                    result = check_cancelled(0)  # 물리적 인덱스 전달
                    print(f"[Debug Cancel] 인자가 있는 취소 확인 결과: {result}")
                    return result
                except Exception as inner_e:
                    print(f"[Error Cancel] 인자 전달 시도 중 오류: {inner_e}")
                    # 오류에도 불구하고 취소를 시도해보자
                    return True
            except Exception as e:
                print(f"[Error Cancel] else 블록의 check_cancelled_adapter 에서 오류: {e}")
                # 예외 발생 시 안전하게 취소를 반환
                return True
            
        print("[Warning] Using original_perform_verification function with " + str(len(verification_list_input)) + " items")
        return original_perform_verification(verification_list_input, update_progress, update_status, result_callback, check_cancelled_adapter)


def perform_microbe_verification(
    microbe_names_list: List[str],
    update_progress: Callable[[float], None] = None,
    update_status: Callable[[str], None] = None,
    result_callback: Callable[[Dict[str, Any]], None] = None,
    context: Union[List[str], str, None] = None,
    check_cancelled: Callable[[], bool] = None
) -> List[Dict[str, Any]]:
    """
    미생물 검증 수행을 위한 브릿지 함수 - 공통 검증 모듈 사용
    
    Args:
        microbe_names_list: 검증할 미생물 이름 목록
        update_progress: 진행 상태 업데이트 콜백
        update_status: 상태 메시지 업데이트 콜백
        result_callback: 개별 결과 업데이트 콜백
        context: 검증 컨텍스트 (파일 경로 또는 학명 리스트)
        check_cancelled: 취소 여부 확인 함수
        
    Returns:
        미생물 검증 결과 목록
    """
    # 공통 검증 모듈 사용
    from species_verifier.gui.common_verifier import perform_common_verification
    from species_verifier.core.verifier import verify_microbe_name
    from species_verifier.utils.helpers import create_basic_microbe_result
    
    # 개별 검증 함수 정의
    def verify_item(item):
        """개별 미생물 검증 함수"""
        try:
            # LPSN API 호출이 있는지 확인
            if 'verify_microbe_name' in globals() or verify_microbe_name:
                result = verify_microbe_name(item)
            else:
                # 기본 결과 생성
                result = create_basic_microbe_result(item, item, False, "LPSN API 호출 실패")
            
            # 입력 이름 추가
            result['input_name'] = item
            return result
        except Exception as e:
            print(f"[Error Bridge] 미생물 검증 중 오류: {e}")
            # 오류 발생 시 기본 결과 반환
            return create_basic_microbe_result(item, item, False, f"검증 오류: {str(e)}")
    
    print(f"[Info Bridge] 미생물 검증 시작 - 공통 검증 모듈 사용 (총 {len(microbe_names_list)}개 항목)")
    
    # 공통 검증 루프 사용
    results = perform_common_verification(
        items_list=microbe_names_list,
        verification_function=verify_item,
        update_progress=update_progress,
        update_status=update_status,
        result_callback=lambda result, verification_type='microbe': result_callback(result, verification_type) if result_callback else None,
        check_cancelled=check_cancelled,
        verification_type="microbe"
    )
    
    return results
    
    # 더 이상 사용하지 않는 코드 제거
    if False and HAS_CORE_MODULES and MicrobeVerifier:
        pass


def perform_col_verification(
    col_names_list: List[Union[str, Tuple[str, str]]],
    update_progress: Callable[[float, int, int], None] = None,
    update_status: Callable[[str], None] = None,
    result_callback: Callable[[Dict[str, Any], str], None] = None,
    check_cancelled: Callable[[], bool] = None
) -> List[Dict[str, Any]]:
    """
    통합생물(COL) 검증 함수 - 공통 검증 모듈 사용
    
    Args:
        col_names_list: 검증할 통합생물 이름 목록
        update_progress: 진행률 업데이트 콜백
        update_status: 상태 업데이트 콜백
        result_callback: 개별 결과 업데이트 콜백
        check_cancelled: 취소 여부 확인 함수
        
    Returns:
        검증 결과 목록
    """
    # 공통 검증 모듈 사용
    from species_verifier.gui.common_verifier import perform_common_verification
    from species_verifier.core.col_api import verify_col_species
    
    # 개별 검증 함수 정의
    def verify_item(item):
        """개별 COL 항목 검증 함수"""
        try:
            # 항목이 튜플/리스트인 경우 (한글명, 학명)
            if isinstance(item, (tuple, list)):
                input_name = item[0]  # 원본 입력 이름
                scientific_name = item[1] if len(item) > 1 else item[0]  # 학명 쿼리
                result = verify_col_species(scientific_name)
                result['input_name'] = input_name  # 원본 입력 이름 추가
            else:
                # 일반 학명 문자열인 경우
                result = verify_col_species(item)
                result['input_name'] = item  # 입력 이름 추가
            
            return result
        except Exception as e:
            print(f"[Error Bridge] COL 검증 중 오류: {e}")
            # 오류 발생 시 기본 결과 반환
            return {
                'input_name': item if isinstance(item, str) else item[0],
                'valid': False,
                'scientific_name': '',
                'status': f"검증 오류: {str(e)}"
            }
    
    print(f"[Info Bridge] 통합생물(COL) 검증 시작 - 공통 검증 모듈 사용 (총 {len(col_names_list)}개 항목)")
    
    # 공통 검증 루프 사용
    results = perform_common_verification(
        items_list=col_names_list,
        verification_function=verify_item,
        update_progress=update_progress,
        update_status=update_status,
        result_callback=lambda result, verification_type='col': result_callback(result, verification_type) if result_callback else None,
        check_cancelled=check_cancelled,
        verification_type="col"
    )
    
    return results
        try:
            # 수정: Verifier 인스턴스 생성 및 콜백 전달
            verifier = MicrobeVerifier(
                progress_callback=update_progress,
                status_update_callback=update_status,
                result_callback=result_callback
            )
            print(f"[Bridge] Calling MicrobeVerifier.perform_microbe_verification for {len(microbe_names_list)} items...")
            
            # 검증 전 입력 학명 수 출력
            print(f"[Debug Bridge] 검증할 미생물 학명 수: {len(microbe_names_list)}")
            if microbe_names_list and len(microbe_names_list) > 0:
                print(f"[Debug Bridge] 검증할 미생물 학명 샘플: {microbe_names_list[:min(5, len(microbe_names_list))]}")
            
            # 취소 확인 함수가 있는 경우 전달
            if check_cancelled:
                # 취소 확인 함수를 전달하는 경우
                print("[Debug Bridge] 취소 확인 함수 전달 준비 완료")
                # 취소 여부 확인 래퍼 함수 정의
                original_perform = verifier.perform_microbe_verification
                
                def perform_with_cancel_check(*args, **kwargs):
                    # 각 학명에 대한 검증 전 취소 여부 확인
                    if check_cancelled and check_cancelled():
                        print("[Info Bridge] 검증 취소 요청 받음")
                        return []
                    return original_perform(*args, **kwargs)
                
                # 원래 함수 대체
                verifier.perform_microbe_verification = perform_with_cancel_check
            
            # MicrobeVerifier의 메서드 호출 시 context 전달
            results = []
            # 각 항목을 개별적으로 처리하여 취소 가능하게 함
            for i, name in enumerate(microbe_names_list):
                # 취소 여부 확인
                if check_cancelled and check_cancelled():
                    print("[Info Bridge] 검증 취소 요청 받음 - 반복 중단")
                    break
                
                # 진행률 업데이트
                if update_progress:
                    progress = (i + 1) / len(microbe_names_list)
                    print(f"[Debug Bridge Progress] 미생물 진행률 계산: {progress:.2f}, 현재 항목: {i+1}, 전체 항목 수: {len(microbe_names_list)}")
                    # 현재 항목과 전체 항목 수도 함께 전달
                    update_progress(progress, i+1, len(microbe_names_list))
                
                # 상태 메시지 업데이트
                if update_status:
                    update_status(f"미생물 검증 중: {name} ({i+1}/{len(microbe_names_list)}) - 전체 {len(microbe_names_list)}개 중 {i+1}번째")
                
                # 단일 항목 검증 실행
                try:
                    single_result = verifier.perform_microbe_verification([name], context=context)
                    if single_result and len(single_result) > 0:
                        # 결과가 있는 경우 추가
                        results.extend(single_result)
                        # 콜백 함수 호출
                        if result_callback and single_result[0]:
                            result_callback(single_result[0], "microbe")
                except Exception as item_e:
                    print(f"[Error Bridge] 항목 '{name}' 검증 중 오류: {item_e}")
            
            # 결과 확인
            print(f"[Debug Bridge] 검증 결과 수: {len(results) if results else 0}")
            return results
        except Exception as e:
            print(f"[Error] Core module microbe verification failed, falling back to original: {e}")
            # 오류 발생 시 원래 함수로 폴백
            print(f"[Debug Bridge] 원래 함수로 폴백 시도, 학명 수: {len(microbe_names_list)}")
            return original_perform_microbe_verification(microbe_names_list, update_progress, update_status, result_callback, check_cancelled)
    else:
        print("[Bridge] Falling back to original_perform_microbe_verification")
        print(f"[Debug Bridge] 원래 함수로 폴백, 학명 수: {len(microbe_names_list)}")
        return original_perform_microbe_verification(microbe_names_list, update_progress, update_status, result_callback, check_cancelled)


def process_file(file_path: str, korean_mode: bool = False) -> List[Union[str, Tuple[str, str]]]:
    """
    파일에서 해양생물 학명 추출을 위한 브릿지 함수 - 공통 파일 처리 모듈 사용
    
    Args:
        file_path: 파일 경로
        korean_mode: 한글명-학명 쌍 모드 여부
        
    Returns:
        추출된 학명 목록 또는 (한글명, 학명) 쌍 목록
    """
    # 공통 파일 처리 모듈 사용
    from species_verifier.gui.common_file_processor import process_species_file
    
    print(f"[Info Bridge] 해양생물 학명 추출 시작 - 공통 파일 처리 모듈 사용")
    results = process_species_file(file_path, korean_mode)
    print(f"[Info Bridge] 해양생물 학명 추출 완료: {len(results)}개 항목")
    
    return results
    
    results = []
    file_extension = os.path.splitext(file_path)[1].lower()
    
    # 파일 확장자별 처리
    try:
        if file_extension in ['.xlsx', '.xls']:
            # 엑셀 파일 처리
            try:
                # 헤더가 있는지 확인 시도
                df_sample = pd.read_excel(file_path, nrows=5)
                print(f"[Info Bridge] 헤더 식별됨: '{df_sample.columns[0]}'")
                
                # 헤더가 있는 것으로 간주
                print(f"[Info Bridge] 파일에 헤더가 있습니다. header=0으로 로드합니다.")
                df = pd.read_excel(file_path)
                print(f"[Debug Bridge] DataFrame 로드 성공. 컬럼: {list(df.columns)}")
                print(f"[Debug Bridge] DataFrame 행 수: {len(df)}")
                
                # 한글명 모드 처리
                if korean_mode and len(df.columns) >= 2:
                    korean_col = df.columns[0]
                    sci_col = df.columns[1]
                    
                    # 한글명-학명 쌍으로 결과 생성
                    for idx, row in df.iterrows():
                        korean_name = str(row[korean_col]).strip()
                        scientific_name = str(row[sci_col]).strip()
                        
                        # 빈 값이 아닐 경우에만 추가
                        if korean_name and scientific_name and korean_name.lower() not in ['nan', 'none', ''] and scientific_name.lower() not in ['nan', 'none', '']:
                            results.append((korean_name, scientific_name))
                else:
                    # 학명만 추출
                    print(f"[Info Bridge] 학명 모드로 처리합니다. 전체 {len(df)} 행의 데이터를 처리합니다.")
                    
                    # 첫 번째 컬럼 정보 확인
                    first_col = df.columns[0]
                    if len(df) > 0:
                        sample_items = df[first_col].head(5).tolist()
                        print(f"[Debug Bridge] 첫 번째 컬럼의 처음 5개 항목: {sample_items}")
                    
                    # 해양생물.xlsx 파일 특별 처리
                    file_basename = os.path.basename(file_path).lower()
                    is_special_file = ('gadus morhua' in str(first_col).lower() or '해양생물' in file_basename)
                    
                    if is_special_file:
                        print(f"[Info Bridge] 해양생물.xlsx 파일 형식 감지, 특별 처리 적용")
                        
                        # 순서대로 첫 번째 컬럼에서 모든 항목 추출
                        all_species = []
                        for idx, row in df.iterrows():
                            try:
                                value = str(row[first_col]).strip()
                                if value and value.lower() not in ['nan', 'none', ''] and ' ' in value and len(value) > 3:
                                    all_species.append(value)
                            except Exception as e:
                                print(f"[Debug Bridge] 항목 추출 중 오류: {e}")
                                continue
                        
                        print(f"[Debug Bridge] 추출된 전체 종 수: {len(all_species)}")
                        
                        # 결과에 추가 - 모든 항목 유지
                        results = []  # 기존 결과 초기화
                        for species in all_species:
                            results.append(species)
                        
                        print(f"[Debug Bridge] 최종 추출된 종 수: {len(results)}")
                    else:
                        # 일반적인 처리: 모든 컬럼에서 유효한 학명 찾기
                        for col in df.columns:
                            for idx, row in df.iterrows():
                                try:
                                    value = str(row[col]).strip()
                                    # 빈 값이 아니고 유효한 학명 형태인 경우만 추가
                                    if value and value.lower() not in ['nan', 'none', ''] and ' ' in value and len(value) > 3:
                                        # 중복 방지
                                        if value not in results:
                                            results.append(value)
                                except Exception as val_e:
                                    print(f"[Debug Bridge] 값 처리 중 무시된 오류: {val_e}")
                                    continue
            except Exception as e:
                print(f"[Error Bridge] 엑셀 파일 처리 중 오류: {e}")
                # 헤더 없이 다시 시도
                try:
                    print(f"[Info Bridge] 헤더 없이 다시 시도합니다.")
                    df = pd.read_excel(file_path, header=None)
                    print(f"[Debug Bridge] 헤더 없이 DataFrame 행 수: {len(df)}")
                    
                    if korean_mode and df.shape[1] >= 2:
                        for idx, row in df.iterrows():
                            korean_name = str(row[0]).strip()
                            scientific_name = str(row[1]).strip()
                            if korean_name and scientific_name and korean_name.lower() not in ['nan', 'none', ''] and scientific_name.lower() not in ['nan', 'none', '']:
                                results.append((korean_name, scientific_name))
                    else:
                        # 모든 컬럼에서 유효한 학명 찾기
                        for col in range(df.shape[1]):
                            for idx, row in df.iterrows():
                                try:
                                    value = str(row[col]).strip()
                                    # 빈 값이 아니고 유효한 학명 형태인 경우만 추가
                                    if value and value.lower() not in ['nan', 'none', ''] and ' ' in value and len(value) > 3:
                                        # 중복 방지
                                        if value not in results:
                                            results.append(value)
                                except Exception as val_e:
                                    continue
                except Exception as inner_e:
                    print(f"[Error Bridge] 헤더 없이 시도 중 오류: {inner_e}")
                    raise RuntimeError(f"엑셀 파일 '{file_path}' 처리 실패")
        
        elif file_extension == '.csv':
            # CSV 파일 처리
            try:
                # 헤더가 있는지 확인
                df_sample = pd.read_csv(file_path, nrows=5, encoding='utf-8')
                
                # 헤더가 있는 것으로 간주
                df = pd.read_csv(file_path, encoding='utf-8')
                print(f"[Debug Bridge] CSV DataFrame 행 수: {len(df)}")
                
                # 한글명 모드 처리
                if korean_mode and len(df.columns) >= 2:
                    korean_col = df.columns[0]
                    sci_col = df.columns[1]
                    
                    # 한글명-학명 쌍으로 결과 생성
                    for idx, row in df.iterrows():
                        korean_name = str(row[korean_col]).strip()
                        scientific_name = str(row[sci_col]).strip()
                        
                        # 빈 값이 아닐 경우에만 추가
                        if korean_name and scientific_name and korean_name.lower() not in ['nan', 'none', ''] and scientific_name.lower() not in ['nan', 'none', '']:
                            results.append((korean_name, scientific_name))
                else:
                    # 학명 모드 처리 - 모든 컬럼에서 유효한 학명 찾기
                    for col in df.columns:
                        for idx, row in df.iterrows():
                            try:
                                value = str(row[col]).strip()
                                # 빈 값이 아니고 유효한 학명 형태인 경우만 추가
                                if value and value.lower() not in ['nan', 'none', ''] and ' ' in value and len(value) > 3:
                                    # 중복 방지
                                    if value not in results:
                                        results.append(value)
                            except Exception as val_e:
                                continue
            except Exception as e:
                print(f"[Error Bridge] CSV 파일 처리 중 오류: {e}")
                # 헤더 없이 다시 시도
                try:
                    df = pd.read_csv(file_path, header=None, encoding='utf-8')
                    print(f"[Debug Bridge] 헤더 없이 CSV DataFrame 행 수: {len(df)}")
                    
                    if korean_mode and df.shape[1] >= 2:
                        for idx, row in df.iterrows():
                            korean_name = str(row[0]).strip()
                            scientific_name = str(row[1]).strip()
                            if korean_name and scientific_name and korean_name.lower() not in ['nan', 'none', ''] and scientific_name.lower() not in ['nan', 'none', '']:
                                results.append((korean_name, scientific_name))
                    else:
                        # 모든 컬럼에서 유효한 학명 찾기
                        for col in range(df.shape[1]):
                            for idx, row in df.iterrows():
                                try:
                                    value = str(row[col]).strip()
                                    # 빈 값이 아니고 유효한 학명 형태인 경우만 추가
                                    if value and value.lower() not in ['nan', 'none', ''] and ' ' in value and len(value) > 3:
                                        # 중복 방지
                                        if value not in results:
                                            results.append(value)
                                except Exception as val_e:
                                    continue
                except Exception as inner_e:
                    print(f"[Error Bridge] 헤더 없이 CSV 시도 중 오류: {inner_e}")
                    # UTF-8이 아닐 경우 CP949로 다시 시도
                    try:
                        df = pd.read_csv(file_path, header=None, encoding='cp949')
                        print(f"[Debug Bridge] CP949 인코딩 CSV DataFrame 행 수: {len(df)}")
                        
                        if korean_mode and df.shape[1] >= 2:
                            for idx, row in df.iterrows():
                                korean_name = str(row[0]).strip()
                                scientific_name = str(row[1]).strip()
                                if korean_name and scientific_name and korean_name.lower() not in ['nan', 'none', ''] and scientific_name.lower() not in ['nan', 'none', '']:
                                    results.append((korean_name, scientific_name))
                        else:
                            # 모든 컬럼에서 유효한 학명 찾기
                            for col in range(df.shape[1]):
                                for idx, row in df.iterrows():
                                    try:
                                        value = str(row[col]).strip()
                                        # 빈 값이 아니고 유효한 학명 형태인 경우만 추가
                                        if value and value.lower() not in ['nan', 'none', ''] and ' ' in value and len(value) > 3:
                                            # 중복 방지
                                            if value not in results:
                                                results.append(value)
                                    except Exception as val_e:
                                        continue
                    except Exception as cp_e:
                        print(f"[Error Bridge] CP949 인코딩으로 시도 중 오류: {cp_e}")
                        raise RuntimeError(f"CSV 파일 '{file_path}' 처리 실패")
        else:
            # 지원하지 않는 파일 형식
            raise ValueError(f"지원하지 않는 파일 형식: {file_extension}")
            print(f"[Debug Bridge] DataFrame 로드 성공. 컬럼: {df.columns.tolist()}")
            
            # DataFrame에서 데이터 추출
            if df.columns.name is None and not any(isinstance(col, str) and col.lower() in ['scientific_name', 'scientificname', 'scientific name', 'name', '학명', 'species'] for col in df.columns):
                # 헤더 없는 경우 (이미 header=None으로 로드됨)
                print("[Info Bridge] 헤더 없는 파일로 처리. 첫 번째 컬럼 사용.")
                if not df.empty and len(df.columns) > 0:
                    scientific_names = df.iloc[:, 0].dropna().astype(str).tolist()
            else:
                # 헤더 있는 경우
                found_target_col = False
                for col in df.columns:
                    if isinstance(col, str) and col.lower() in ['scientific_name', 'scientificname', 'scientific name', 'name', '학명', 'species']:
                        print(f"[Info Bridge] 대상 컬럼 찾음: '{col}'")
                        scientific_names = df[col].dropna().astype(str).tolist()
                        found_target_col = True
                        break
                
                # 적합한 컬럼 못 찾으면 첫 번째 컬럼 사용
                if not found_target_col and not df.empty and len(df.columns) > 0:
                    print("[Info Bridge] 적합한 헤더 컬럼 없음. 첫 번째 컬럼 사용.")
                    for item in df.iloc[:, 0].dropna().astype(str).tolist():
                        if item and item.lower() not in ['nan', 'none', ''] and ' ' in item and len(item) > 3:
                            if item not in results:
                                results.append(item)
                    
    except Exception as e:
        import traceback
        print(f"[Error Bridge] 파일 처리 중 예측 못한 오류 발생: {e}")
        print(traceback.format_exc())
        return []
    
    # 결과 요약 로그
    print(f"[Info Bridge] 최종 추출된 학명 수: {len(results)}")
    if results:
        print(f"[Info Bridge] 최종 학명 샘플: {results[:min(5, len(results))]}")
    
    return results


def process_microbe_file(file_path: str, korean_mode: bool = False) -> List[Union[str, Tuple[str, str]]]:
    """
    파일에서 미생물 학명 추출을 위한 브릿지 함수 - 공통 파일 처리 모듈 사용
    
    Args:
        file_path: 파일 경로
        korean_mode: 한글명-학명 쌍 모드 여부 (기본값: False)
        
    Returns:
        추출된 미생물 학명 목록 또는 (한글명, 학명) 쌍 목록
    """
    # 공통 파일 처리 모듈 사용
    from species_verifier.gui.common_file_processor import process_species_file
    
    print(f"[Info Bridge] 미생물 학명 추출 시작 - 공통 파일 처리 모듈 사용")
    results = process_species_file(file_path, korean_mode)
    print(f"[Info Bridge] 미생물 학명 추출 완료: {len(results)}개 항목")
    
    return results


def process_col_file(file_path: str, korean_mode: bool = False) -> List[Union[str, Tuple[str, str]]]:
    """
    파일에서 통합생물(COL) 학명 추출을 위한 브릿지 함수 - 공통 파일 처리 모듈 사용
    
    Args:
        file_path: 파일 경로
        korean_mode: 한글명-학명 쌍 모드 여부 (기본값: False)
        
    Returns:
        추출된 통합생물 학명 목록 또는 (한글명, 학명) 쌍 목록
    """
    # 공통 파일 처리 모듈 사용
    from species_verifier.gui.common_file_processor import process_species_file
    
    print(f"[Info Bridge] 통합생물(COL) 학명 추출 시작 - 공통 파일 처리 모듈 사용")
    results = process_species_file(file_path, korean_mode)
    print(f"[Info Bridge] 통합생물(COL) 학명 추출 완료: {len(results)}개 항목")
    
    return results
    
    def is_valid_species_name(name):
        """학명으로 유효한지 확인하는 함수"""
        if not isinstance(name, str):
            return False
            
        name = name.strip()
        # 빈 문자열 제외
        if not name or len(name) < 3:
            return False
            
        # 숫자로만 구성된 문자열 제외
        if name.isdigit():
            return False
            
        # 일반적인 학명 패턴 확인 (두 단어 이상으로 구성, 첫 단어는 대문자로 시작)
        words = name.split()
        if len(words) >= 2 and re.match(r'^[A-Z][a-z]+', words[0]):
            return True
            
        return False
    
    def extract_names_from_dataframe(df, has_header=False):
        """데이터프레임에서 이름 추출 - 개선된 버전"""
        names = []
        header_keywords = ['scientific_name', 'scientificname', 'scientific name', 'name', '학명', 'species', 'microbe', 'bacteria', 'taxon']
        target_column = None
        
        # 1. 헤더 키워드로 컬럼 찾기
        if has_header:
            for col in df.columns:
                if any(keyword in str(col).lower() for keyword in header_keywords):
                    print(f"[Info Bridge] 대상 컬럼 발견: {col}")
                    target_column = col
                    break
        
        # 2. 키워드로 찾지 못했거나 헤더가 없는 경우 첫 번째 컬럼 사용
        if target_column is None and len(df.columns) > 0:
            target_column = df.columns[0]
            print(f"[Info Bridge] 키워드 컬럼 없음. 첫 번째 컬럼 사용: {target_column}")
        
        # 3. 대상 컬럼에서 데이터 추출
        if target_column is not None:
            values = df[target_column].dropna().astype(str).tolist()
            # 유효한 학명만 필터링
            filtered_values = [name for name in values if is_valid_species_name(name)]
            
            # 필터링 결과 로그
            print(f"[Debug Bridge] 총 {len(values)}개 값 중 {len(filtered_values)}개 유효한 학명 발견")
            
            # 필터링된 결과가 없으면 원본 값 사용
            if not filtered_values and values:
                print("[Warning Bridge] 유효한 학명 형식 없음. 원본 값 사용")
                names.extend(values)
            else:
                names.extend(filtered_values)
        
        # 4. 백업: 만약 학명을 못 찾았는데 다른 컬럼이 있다면 두 번째 컬럼 시도
        if not names and len(df.columns) > 1:
            print("[Info Bridge] 첫 번째 컬럼에서 학명 찾지 못함. 두 번째 컬럼 시도")
            second_column = df.columns[1]
            values = df[second_column].dropna().astype(str).tolist()
            filtered_values = [name for name in values if is_valid_species_name(name)]
            
            if filtered_values:
                print(f"[Info Bridge] 두 번째 컬럼에서 {len(filtered_values)}개 학명 발견")
                names.extend(filtered_values)
            elif values:
                print("[Warning Bridge] 두 번째 컬럼에서 유효한 학명 형식 없음. 원본 값 사용")
                names.extend(values)
        
        return names
    
    # 파일 확장자에 따라 다른 처리
    if file_ext == '.csv':
        # UTF-8 인코딩으로 시도
        for encoding in ['utf-8', 'cp949', 'euc-kr']:
            try:
                # 파일 전체를 읽어서 처리
                df = pd.read_csv(file_path, encoding=encoding, dtype=str, keep_default_na=False, low_memory=False)
                
                # 헤더 확인
                header_keywords = ['scientific_name', 'scientificname', 'scientific name', 'name', '학명', 'species', 'microbe', 'bacteria']
                has_header = any(any(keyword in str(col).lower() for keyword in header_keywords) for col in df.columns)
                
                if has_header:
                    print(f"[Info Bridge] CSV 파일에 헤더가 있습니다. ({encoding} 인코딩)")
                    microbe_names = extract_names_from_dataframe(df, has_header=True)
                else:
                    print(f"[Info Bridge] CSV 파일에 헤더가 없습니다. ({encoding} 인코딩)")
                    microbe_names = extract_names_from_dataframe(df, has_header=False)
                
                # 데이터가 제대로 읽혔으면 루프 종료
                if len(microbe_names) > 0:
                    break
                    
            except UnicodeDecodeError:
                print(f"[Info Bridge] {encoding} 인코딩 실패, 다음 인코딩 시도...")
                continue
            except Exception as e:
                print(f"[Error Bridge] CSV 파일 처리 중 오류 ({encoding}): {e}")
                continue
                
        if not microbe_names:
            print("[Warning Bridge] 모든 인코딩 시도 실패. 첫 번째 컬럼으로 시도합니다.")
            try:
                df = pd.read_csv(file_path, header=None, dtype=str, keep_default_na=False, low_memory=False)
                microbe_names = df[0].dropna().astype(str).tolist()
            except Exception as e:
                print(f"[Error Bridge] CSV 파일 처리 최종 실패: {e}")
                return []
    
    # Excel 파일 처리
    elif file_ext in ['.xlsx', '.xls']:
        try:
            # 첫 번째 시트 읽기
            xls = pd.ExcelFile(file_path)
            sheet_name = xls.sheet_names[0]  # 첫 번째 시트 사용
            df = pd.read_excel(file_path, sheet_name=sheet_name, dtype=str, keep_default_na=False)
            print(f"[Debug Bridge] DataFrame 로드 성공. 컬럼: {list(df.columns)}")
            print(f"[Debug Bridge] DataFrame 행 수: {len(df)}")
            
            # 헤더 확인
            header_keywords = ['scientific_name', 'scientificname', 'scientific name', 'name', '학명', 'species', 'microbe', 'bacteria']
            has_header = any(any(keyword in str(col).lower() for keyword in header_keywords) for col in df.columns)
            
            if has_header:
                print("[Info Bridge] Excel 파일에 헤더가 있습니다.")
                microbe_names = extract_names_from_dataframe(df, has_header=True)
            else:
                print("[Info Bridge] Excel 파일에 헤더가 없습니다.")
                microbe_names = extract_names_from_dataframe(df, has_header=False)
                
            # 첫 번째 열만 사용해보기 (데이터가 없을 경우)
            if not microbe_names and len(df.columns) > 0:
                print("[Info Bridge] 첫 번째 열만 사용하여 시도합니다.")
                # 첫 번째 열의 모든 행을 가져옴
                microbe_names = df.iloc[:, 0].dropna().astype(str).tolist()
                
        except Exception as e:
            print(f"[Error Bridge] Excel 파일 처리 중 오류: {e}")
            return []
    
    # 텍스트 파일 처리
    elif file_ext in ['.txt', '.tsv']:
        try:
            # 인코딩 시도 (UTF-8, CP949, EUC-KR 순서로 시도)
            encodings = ['utf-8', 'cp949', 'euc-kr']
            lines = []
            
            for encoding in encodings:
                try:
                    with open(file_path, 'r', encoding=encoding) as f:
                        lines = [line.strip() for line in f.readlines() if line.strip()]
                    print(f"[Info Bridge] {encoding} 인코딩으로 파일을 성공적으로 읽었습니다.")
                    break
                except UnicodeDecodeError:
                    print(f"[Info Bridge] {encoding} 인코딩 실패, 다음 인코딩 시도...")
                    continue
            
            if not lines:
                print("[Warning Bridge] 파일을 읽을 수 없거나 비어 있습니다.")
                return []
            
            # 헤더 확인 (첫 줄이 헤더 키워드를 포함하는지 확인)
            header_keywords = ['scientific_name', 'scientificname', 'scientific name', 'name', '학명', 'species', 'microbe', 'bacteria']
            has_header = any(keyword in lines[0].lower() for keyword in header_keywords)
            
            if has_header:
                print("[Info Bridge] 텍스트 파일에 헤더가 있습니다. 첫 줄을 제외합니다.")
                microbe_names = lines[1:]
            else:
                print("[Info Bridge] 텍스트 파일에 헤더가 없습니다. 모든 줄을 처리합니다.")
                microbe_names = lines
                
        except Exception as e:
            print(f"[Error Bridge] 텍스트 파일 처리 중 오류: {e}")
            return []
    
    # 결과 후처리
    try:
        # 빈 문자열 제거 및 중복 제거
        microbe_names = [name for name in microbe_names if name and str(name).strip()]
        microbe_names = list(dict.fromkeys(microbe_names))  # 순서 유지하며 중복 제거
        
        print(f"[Info Bridge] 최종 추출된 미생물 학명 수: {len(microbe_names)}")
        if microbe_names:
            print(f"[Info Bridge] 미생물 학명 샘플: {microbe_names[:min(5, len(microbe_names))]}")
        
        return microbe_names
        
    except Exception as e:
        print(f"[Error Bridge] 결과 처리 중 오류: {e}")
        return []
    
    # 처리할 수 없는 파일 형식인 경우
    else:
        print(f"[Error Bridge] 지원하지 않는 파일 형식: {file_ext}")
        return []


def get_wiki_summary(search_term: str) -> str:
    """
    위키백과 요약 검색을 위한 브릿지 함수
    
    Args:
        search_term: 검색어
        
    Returns:
        위키백과 요약
    """
    if HAS_CORE_MODULES:
        try:
            # 코어 모듈 사용
            return get_wiki_summary(search_term)
        except Exception as e:
            print(f"[Error] Core wiki search failed, falling back to original: {e}")
            # 예외 발생 시 기존 함수로 폴백
            return original_get_wiki_summary(search_term)
    else:
        # 코어 모듈이 없는 경우 기존 함수 사용
        return original_get_wiki_summary(search_term)


async def process_batch(names: List[str], callback: Callable[[Dict[str, Any]], None]) -> List[Dict[str, Any]]:
    """
    학명 목록을 배치로 처리합니다.
    
    Args:
        names: 처리할 학명 목록
        callback: 결과를 처리할 콜백 함수
        
    Returns:
        처리된 결과 목록
    """
    results = []
    for name in names:
        try:
            # 여기에 API 호출 로직이 들어감 (verify_species는 예시)
            result = await verify_species(name)  # 비동기 검증 함수 호출
            if callback:
                callback(result)
            results.append(result)
            # API 호출 후 지연 시간 추가
            await asyncio.sleep(api_config.REQUEST_DELAY)
        except Exception as e:
            print(f"[Error] 처리 중 오류 발생: {e}")
            results.append({"name": name, "error": str(e)})
            # 오류 발생 시에도 잠시 대기하여 연속 오류 방지
            await asyncio.sleep(api_config.REQUEST_DELAY)
    return results 